# -*- coding: utf-8 -*-
"""Project 2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_GXCP_CYUxDsW4QtazrRLdKvNoOQxUEK

Notes:
- Complex project and not so convenient in Google Colab. I would be better to have different files, but not so easy to do here.
- Execute cells in order. Each cell correponds to one "independent" python file

# Basic functions
You do **not** need to modify this file but I recommend you to look at them out of curiosity.

In particular check the function `swap`. You will use it in your programs.
"""

# Core functions related to sorting
from random import sample

def create_random_array(n):
  """ Create an array (list) of n distinct numbers """
  if n < 0: raise ValueError("negative size")
  return sample(range(10*n), k=n)

def swap(array, i, j):
  """ Swap elements at indexes i and j in the array """
  # test validity
  if i >= len(array): raise IndexError(f"index i out of bounds (i={i})")
  if j >= len(array): raise IndexError(f"index j out of bounds (j={j})")
  if i == j: return 
  # swap the values
  tmp = array[i]
  array[i] = array[j]
  array[j] = tmp
    
def is_sorted(array):
  """ Check if the array given as input is sorted """
  for i in range(1,len(array)):
    if array[i-1] > array[i]: return False
  return True

"""# Sorting Algorithms
A short list of famous sorting algorithms

## Insertion Sort
You do **not** need to modify this "file".

Implementation of the insertion sort algorithm.
"""

# INSERTION SORT
#
# IN:  arbitrary array
# OUT: array with all values sorted in increasing order
#
# METHOD:
# conceptually, consider two arrays: sorted, unsorted
# initially,
#   sorted   = []
#   unsorted = array
# take element elt from unsorted one by one
#   insert elt into sorted and move it down
#   until it reaches its correct position
#
# NB: in the code below, index i represents the "border"
# between sorted and unsorted.

def insert_sort(array):
  """ Non-destructive insertion sort:
  array is unchanged
  returns a sorted copy
  """
  res = array.copy()
  insert_sort_inplace_optimized(res)
  return res

def insert_sort_inplace(array):
  """ Inplace insertion sort """
  for i in range(len(array)):
    for j in range(i-1, -1, -1):
      if array[j] > array[j+1]:
        swap(array, j, j+1)
  return array

def insert_sort_inplace_optimized(array):
  """ Inplace insertion sort (slightly optimized) """
  for i in range(len(array)):
    for j in range(i-1, -1, -1):
      if array[j] > array[j+1]:
        swap(array, j, j+1)
      else:
        break
  return array

# # Simple test
N = 10
A = create_random_array(N)
B = insert_sort(A)
print(A)
print(B)

"""## Quick Sort
You do **not** need to modify this "file".

Implementation of the quicksort algorithm.
"""

# QUICKSORT
#
# IN:  arbitrary array
# OUT: array with all values sorted in increasing order
#
# METHOD:
# recursively,
#   take one value from the array as pivot
#   split the remainder of the array into two arrays:
#      left array with values smaller than pivot
#      right array with values larger than pivot
#   sort left and right independently
#   combine left, pivot, right into a sorted array
#
# NB: in practice, the way to chose the pivot is very
# significant to ensure good performance. However, in
# this lecture, we make a naive choice in order to keep
# the discussion simple and focus instead on the core
# idea of the algorithm.
# 
#
# Non-destructive sort:
# array is unchanged
# returns a sorted copy
#

def quick_sort(array):
  """ Sorting function (quicksort)
  IN: arbitrary array
  OUT: sorted array
  """
  if len(array)  < 2: return array        # 0 or 1 element => trivial
  if len(array) == 2:                     # 2 elements     => easy
    if array[0] <= array[1]: return array
    else: return [array[1], array[0]]     # reverse the list (could use array[::-1])

  # More than 2 elements:
  pivot = array[0]
  tail  = array[1:]
  left  = [ v for v in tail if v < pivot ]
  right = [ v for v in tail if v >= pivot ]
  return quick_sort(left) + [ pivot ] + quick_sort(right)

# # Simple test
N = 10
A = create_random_array(N)
B = quick_sort(A)
print(A)
print(B)

"""## Merge Sort -- **TODO**
- `merge` function is given (recursive and iterative versions)
- **need to write** the `sort` function.

Implementation of the mergesort algorithm.

"""

# MERGE SORT
#
# IN:  arbitrary array
# OUT: array with all values sorted in increasing order
#
# METHOD:
# recursively,
#   cut the array into two halves: left, right
#   sort each half
#   merge both halves
#

#
# Non-destructive sort:
# array is unchanged
# returns a sorted copy
#

def merge_rec(a, b):
  """ Merge of two sorted arrays (recursive version)
  
  IN:  sorted arrays a and b
  OUT: merging of a and b into one sorted array
  """
  if not a or not b or a[-1] < b[0]:    # empty a OR empty b OR last of a < first of b
    return a + b                        # ==> easy case, simply concatenate a and b
  if a[0] < b[0]:                       # Otherwise, take the smaller among the two first elements
    return [a[0]] + merge_rec(a[1:], b) # and do recursion!
  return [b[0]] + merge_rec(a, b[1:])


def merge(a, b):
  """ Merge of two sorted arrays (iterative version)
  
  IN:  sorted arrays a and b
  OUT: merging of a and b into one sorted array
  """
  res = [0] * (len(a)+len(b))    # Create a list of correct length with arbitrary values (here 0)
  indexa = 0                     # index of next element of a to be merged
  indexb = 0                     # index of next element of b to be merged
  for i in range(len(res)):      # 4 cases to distinguish
    if indexa == len(a):         # - already used all elements of a
      res[i] = b[indexb]
      indexb += 1
    elif indexb == len(b):       # - already used all elements of b
      res[i] = a[indexa]
      indexa += 1
    elif a[indexa] < b[indexb]:  # - first element of a is smaller than first element of b
      res[i] = a[indexa]
      indexa += 1
    else:                        # - first element of b is smaller (or equal) than first element of a
      res[i] = b[indexb]
      indexb += 1
  return res
    
def merge_sort(array):
  """ Sorting function (merge sort)
  IN: arbitrary array
  OUT: sorted array
  """
  if len(array)  < 2: return array        
  if len(array) == 2:                     
    if array[0] <= array[1]: return array
    else: return [array[1], array[0]] 

  middle =len(array)//2
  left  = merge_sort(array[0:middle])
  right = merge_sort(array[middle:])
  return  merge(left,right)
  

# # Simple test
N = 10
A = create_random_array(N)
B = merge_sort(A)
print(A)
print(B)

"""## Bubble Sort -- OPTIONAL"""

# BUBBLE SORT
#
# IN:  arbitrary array
# OUT: array with all values sorted in increasing order
#
# METHOD:
#  check online by yourself :)

def bubble_sort(array):
    """ Non-destructive bubblesort sort.    
    array is unchanged; returns a sorted copy
    """
    res = array.copy()
    bubble_sort_inplace(res)
    return res

def bubble_sort_inplace(array):
    """ Inplace bubblesort sort.
    modifies the input array directly
    """
    for i in range(len(array)-1,-1,-1):
        for j in range(i):
            if is_sorted (array):
               break
            if array[j] > array[j+1]:
               swap(array, j, j+1)
              
            
    return array

N = 10
A = create_random_array(N)
B = bubble_sort(A)
print(A)
print(B)

"""## Selection Sort -- OPTIONAL

"""

# SELECTION SORT
#
# IN:  arbitrary array
# OUT: array with all values sorted in increasing order
#
# METHOD:
# conceptually, consider two arrays: sorted, unsorted
# initially,
#   sorted   = []
#   unsorted = array
# iteratively,
#   remove the smallest element of unsorted
#   add it at the end of sorted
#

def selection_sort(array):
  """ Non-destructive selection sort.    
  array is unchanged; returns a sorted copy
  """
  res = array.copy()
  selection_sort_inplace(res)
  return res

def selection_sort_inplace(array):
  """ Inplace selection sort.
  modifies the input array directly
  """
  # TODO (OPTIONAL): implement selection sort
  # replace the lines below with your own code
  list.sort(array)
  return array

N = 10
A = create_random_array(N)
B = selection_sort(A)
print(A)
print(B)

"""## Any Other Sort Algorithm -- OPTIONAL

# Main Program
- This is the main "file" that you should execute to evaluate the sorting algorithms.
- It automatically creates a graphic based on the given parameters.
- You may want to modify some parts of this file: e.g.
ALGORITHMS, REPETITIONS, TEST_SIZES, ...

  If you modify something, explain it in the report
"""

import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats

# List of algorithms to be compared
ALGORITHMS = [
# Algorithm name,   Color,    Algorithm function
  ("Bubble sort",     "Green",  bubble_sort ),
  #("Selection sort",  "Blue",   selection_sort ),
  ("Insertion sort",  "Cyan",   insert_sort ),
  ("Quicksort",       "Orange", quick_sort ),
  ("Merge sort",      "Red",    merge_sort ),
  ("Builtin sort",    "Black",  sorted )
]

# Describe data used to do the comparison
# You can change here to get better results!
REPETITIONS  = 50
TEST_SIZES  = [2,20,100,200,300,400,500]

# Generate the random arrays used in the comparison
TEST_ARRAYS = [ (size,
                 [create_random_array(size) for i in range(REPETITIONS)]
                ) for size in TEST_SIZES ]

# "Complex" function used to compute confidence intervals
# https://en.wikipedia.org/wiki/Confidence_interval
# Code corrresponds to https://en.wikipedia.org/wiki/Confidence_interval#Basic_steps
# No need to understand details here.
def mean_ci(data, conf_level=0.95, two_sided=True):
  if two_sided:
    conf_level = 1 - (1-conf_level)/2
  n    = data.size
  mean = np.mean(data)
  df   = n-1
  sdv  = np.std(data)
  ci   = stats.t.ppf(conf_level, df) * sdv / np.sqrt(n)
  return (mean, ci)


# Measure the time taken to sort a given array using a given sort algorithm
from time import time
def timed_sort(sort_fct, array):
  start = time()
  sorted_array = sort_fct(array)
  stop = time()
  # check that sorting is correct. Otherwise stop everything!
  if not is_sorted(sorted_array):
    print(f"Problem with array {array}, obtain {sorted_array} which is not sorted")
  assert( is_sorted(sorted_array) )
  return (stop-start) * 1000           # get time as milliseconds


# gather execution data to draw nice plot
# May be complex to read but please have a look :)
# Do not hesitate to ask questions
data = [ {} for _ in ALGORITHMS ]

for k, (name, col, sort) in enumerate(ALGORITHMS):
  print(f"- {name}")
  means = np.empty(len(TEST_ARRAYS))
  lcis  = np.empty(len(TEST_ARRAYS))
  hcis  = np.empty(len(TEST_ARRAYS))
  
  for i, (size, arrays) in enumerate(TEST_ARRAYS):
    print(f"  {size},", end="", flush=True)
    times = np.fromiter((timed_sort(sort, array) for array in arrays), float)
    mean, ci = mean_ci(times)
    means[i] = mean
    lcis[i] = mean-ci
    hcis[i] = mean+ci
    
  data[k]['name']  = name
  data[k]['color'] = col
  data[k]['means'] = means
  data[k]['lcis'] = lcis
  data[k]['hcis'] = hcis
  print("...done")


# plot the data using matplotlib
# Current version use a log-log scale
fig, ax = plt.subplots()

for entry in data:
    ax.fill_between(TEST_SIZES, entry['hcis'], entry['lcis'], color=entry['color'], alpha=.25)
    ax.plot(TEST_SIZES, entry['means'], color=entry['color'], label=entry['name'])
    
ax.set_xscale("log", nonposx='clip')    # setting the x-axis values to logarithmic scale and non-positive values in x are clipped to a very small positive number
ax.set_yscale("log", nonposy='clip')    

ax.set_ylim(ymin=0.001)  
ax.set(xlabel='array size', ylabel='running time [ms]',
       title='Running time of sorting algorithms')
ax.legend()
ax.grid()
fig.savefig("sort_comparison.pdf")
plt.show()